## Колодко Вадим, магистрант 1 курс
# Задание: Матричные преобразования. Найти обратную матрицу для матрицы А. Входные данные: целое положительное число n, произвольная матрица А размерности n х n.

Добавил еще выбор количества матриц. Матрица представляет в себе Task(Задание). В однопоточном выполнение всех заданий происходит в потоке самого приложения. Когда этих заданий будет большое количество или же расчет одного задания будет занимать большое количество времени, это не есть хорошо, особенно отчетливо это будет видно в приложении с интерфейсом, когда само приложение повиснет и будет ожидать окончание выполнения задачи, и пользователь не сможет ничего сделать. В многопоточном логика в следующем: я, зная предполагаемую нагрузку на задачу, создаю дополнительный поток, в котором и выполняется задача, что позволяет нам избежать зависаний программы. Количество потоков\процессов можно создавать разное, в зависимости с какой стороны его рассматривать. Если с физической, то не более колличества ядер процессора. Т.е. если процессор 4-х ядерный, он не может выполнять более 4-х потоков одновременно. Если же логической, то пока не закончится память хандлов, то есть много, а именно до 10.000. Перейдем к Сихнронному и Асинхронному программированию. Синхронное представляет из себя поочередность. Закончилось выполнение первого задания, началось выполнение второго задания и т.д. Асинхронное: здесь один поток, запуская некоторую задачу, может остановить на некотором промежутке времени ее выполнение, сохраняя при этом ее текущее состояние, и начать выполнять другую задачу. Время и производительность зависят от самого железа, на котором будет выполняться программа, т.к. каждый поток требует определенный объем памяти. Чем больше создать потоков, тем больше памяти будет задействовано, и это будет влиять на производительность самого железа. Сложность и объем кода зависит уже от поставленной задачи. По отладке асинхронная метода, в интернете информации не нашел. Я потыкался в отладке сам и пришел к следующему заключение: после того как мы попадаем в асинхронную функцию, основной поток продолжает работать и если не поставить никакой паузы, в консольном приложении, то по завершению основоного потока завершается вся отладка. Возможно я бы пришел к другому заключению, будь это приложение с интерфейсом. Но тут у меня есть догадки, возможно и глупые но есть. Когда мы находимся в асинхронном методе, из основого потока, то есть из приложения, мы можем вносить изменения не дожидаясь завершения асинхронного метода что и является ее особенностью.

Подведу небольшой вывод. Для любого приложения важны такие вещи как: удобство использования и производительность. Это реализовать нам позволит Асинхронное программирование. Например, работа с SQL сервером. Скорее всего, сервер работает на другом компьютере в сети и работает под другим процессом, это может занять много времени. И реализовать это все в одном потоке и без оптимизации будет катастрофической ошибкой.

В файле Таблица, я привел время выполнения. Замерял только из основного потока. 
